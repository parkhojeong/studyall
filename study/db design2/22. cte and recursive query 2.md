* all ancestors query
- all ancestors query of category_id=7
```sql
use my_shop4;
with recursive descendent_category as (
    select category_id, name, parent_id , 1 as depth
    from category
    where category_id = 7
    
    union all 
    
    select c.category_id, c.name, c.parent_id, descendent_category.depth+1
    from category c
    join descendent_category on c.category_id = descendent_category.parent_id
)
select * from descendent_category;
```

* specific depth query
```sql
with recursive descendent_category as (
    select category_id, name, parent_id , 1 as depth
    from category
    where category_id = 7
    
    union all 
    
    select c.category_id, c.name, c.parent_id, descendent_category.depth+1
    from category c
    join descendent_category on c.category_id = descendent_category.parent_id
    where descendent_category.depth <= 1 -- until level 2 
)
select * from descendent_category;
```

* breadcrumb navigation
```sql
with recursive descendent_category as (
    select category_id, name, parent_id, cast(name as char) as path 
    from category
    where category_id = 7
    
    union all 
    
    select c.category_id, c.name, c.parent_id, concat(c.name, '>', descendent_category.path)
    from category c
    join descendent_category on c.category_id = descendent_category.parent_id
)
select * from descendent_category;
```

* practice usage example: product count aggregation by category
- requirement: show product count of category including subcategories 
```sql
DROP TABLE IF EXISTS product;

CREATE TABLE product (
  product_id BIGINT   NOT NULL AUTO_INCREMENT,
  name    VARCHAR(200) NOT NULL,
  category_id BIGINT   NOT NULL,
  price    INT     NOT NULL,
  PRIMARY KEY (product_id),
  FOREIGN KEY (category_id) REFERENCES category(category_id)
);

-- 상품 데이터 입력
INSERT INTO product (name, category_id, price) VALUES ('맥북 프로', 7, 2500000);
INSERT INTO product (name, category_id, price) VALUES ('맥북 에어', 7, 1500000);
INSERT INTO product (name, category_id, price) VALUES ('삼성 노트북', 7, 1200000);
INSERT INTO product (name, category_id, price) VALUES ('아이맥', 8, 2000000);
INSERT INTO product (name, category_id, price) VALUES ('아이패드', 9, 800000);
INSERT INTO product (name, category_id, price) VALUES ('아이폰 15', 10, 1300000);
INSERT INTO product (name, category_id, price) VALUES ('갤럭시 S24', 11, 1200000);
INSERT INTO product (name, category_id, price) VALUES ('LG TV', 12, 1500000);
INSERT INTO product (name, category_id, price) VALUES ('삼성 냉장고', 13, 2000000);
```

```sql
with recursive cte as (
    select category_id, name, parent_id
    from category 
    where category_id = 1 
    
    union all
    
    select c.category_id, c.name, c.parent_id 
    from category c 
    join cte on c.parent_id = cte.category_id
)
select count(price)
from product  
where category_id in (select category_id from cte);
```

* cte pros
- variable depth is possible
- single query
- standard sql
- good readability
- additional information: depth, path are available 

* summary
- almost hierarchical structure requirement can be solved with an adjacency list + cte
- in large data or read performance critical situation, a closure table model is considered