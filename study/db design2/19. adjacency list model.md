* what is an adjacency list model?
each row reference own parent. structure that answer is to question "who is my parent?"
core idea
- each node can have fk to its own parent node
- the root node has null because of no parent

```sql
use my_shop4;
create table category(
    category_id int primary key primary key auto_increment,
    name varchar(100),
    parent_id int ,
    foreign key (parent_id) references category(category_id)
)
```
- parent_id is self-referential fk
- this table has a self-referencing relationship

```sql
-- 1단계: 최상위 카테고리 (루트)
INSERT INTO category (name, parent_id) VALUES ('전자제품', NULL); -- id:1
INSERT INTO category (name, parent_id) VALUES ('의류', NULL); -- id:2
INSERT INTO category (name, parent_id) VALUES ('식품', NULL); -- id:3
-- 2단계: 전자제품의 하위 카테고리
INSERT INTO category (name, parent_id) VALUES ('컴퓨터', 1); -- id:4
INSERT INTO category (name, parent_id) VALUES ('스마트폰', 1); -- id:5
INSERT INTO category (name, parent_id) VALUES ('가전제품', 1); -- id:6
-- 3단계: 컴퓨터의 하위 카테고리
INSERT INTO category (name, parent_id) VALUES ('노트북', 4);
INSERT INTO category (name, parent_id) VALUES ('데스크탑', 4);
INSERT INTO category (name, parent_id) VALUES ('태블릿', 4);
-- 3단계: 스마트폰의 하위 카테고리
INSERT INTO category (name, parent_id) VALUES ('애플', 5);
INSERT INTO category (name, parent_id) VALUES ('삼성', 5);
-- 3단계: 가전제품의 하위 카테고리
INSERT INTO category (name, parent_id) VALUES ('TV', 6);
INSERT INTO category (name, parent_id) VALUES ('냉장고', 6);
-- 2단계: 의류의 하위 카테고리
INSERT INTO category (name, parent_id) VALUES ('남성의류', 2);
INSERT INTO category (name, parent_id) VALUES ('여성의류', 2);
-- 3단계: 남성의류의 하위 카테고리
INSERT INTO category (name, parent_id) VALUES ('셔츠', 14);
INSERT INTO category (name, parent_id) VALUES ('바지', 14);
```

* basic query
- root category query
```
select * from category where parent_id is null;
```

- direct child of specific category
```sql
select * from category where parent_id = 1;
```

- parent of specific caetgory
```sql
select p.*
from category c
join category p on c.parent_id = p.category_id
where c.category_id = 4;
```

* adjacency list model pros
- intuitive structure: fk is used for parent-child relationship
- simple to insert/update/delete data: appending and moving node is easy
- storage space efficient: each node needs only one row
- fk constraint is used: reference integrity is guaranteed

- insert/update/delete 
```sql
insert into category(name, parent_id) values('게이밍노트북', 7);

update category set parent_id = 6 where category_id = 7;

delete from category where category_id = 17;
```

* adjacency list model limit
- it is hard to query deep hierarchy at once
  - ex. query to all sub category of electronics product 
- how to know the depth of a node?