```sql
use my_shop5;
DROP TABLE IF EXISTS orders;

CREATE TABLE orders (
  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,
  customer_id BIGINT NOT NULL,
  total_amount INT NOT NULL,
  order_status VARCHAR(20) NOT NULL,
  order_date DATETIME NOT NULL
);

INSERT INTO orders (customer_id, total_amount, order_status, order_date) VALUES
(1, 10000, 'COMPLETED', '2026-01-01 10:00:00'),
(2, 25000, 'COMPLETED', '2026-01-01 14:30:00'),
(3, 15000, 'COMPLETED', '2026-01-01 18:20:00'),
(4, 50000, 'COMPLETED', '2026-01-02 09:15:00'),
(5, 30000, 'COMPLETED', '2026-01-02 11:00:00'),
(6, 12000, 'CANCELLED', '2026-01-02 15:45:00'),
(7, 45000, 'COMPLETED', '2026-01-03 10:00:00');

SET SESSION cte_max_recursion_depth = 1000000;
INSERT INTO orders (customer_id, total_amount, order_status, order_date)
WITH RECURSIVE cte AS (
    SELECT 1 AS n
    UNION ALL
    SELECT n + 1 FROM cte WHERE n < 1000000
)
SELECT
    FLOOR(1 + RAND() * 10000),      -- 1~10000 사이의 랜덤 고객 ID
    FLOOR(1000 + RAND() * 100000),  -- 1000~101000 사이의 랜덤 금액
    IF(RAND() > 0.1, 'COMPLETED', 'CANCELLED'), -- 90% 확률로 완료, 10% 취소
    DATE_ADD('2026-01-01 00:00:00', INTERVAL FLOOR(RAND() * 31536000) SECOND) -- 2026년 내 랜덤 일시
FROM cte;


```

requirement: daily sales report
```sql
select
    date(order_date) as stat_date,
    count(*) as order_count,
    sum(total_amount) 
from orders
group by date(order_date)
order by stat_date;
```

* why is an aggregation query using the original table dangerous?
1. performance issue: aggregation query hard to use index. if index is used, the range is big 
2. db load: cpu,memory load
3. service failure propagation: other services might be affected 