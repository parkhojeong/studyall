* valid period idea
- valid_from
- valid_to: current data is null or distant date
```sql
use my_shop4;
DROP TABLE IF EXISTS product;
create table product
(
    history_id     bigint primary key auto_increment,
    product_id     bigint       not null,
    name           varchar(200) not null,
    price          int          not null,
    stock_quantity int          not null default 0,
    status         varchar(20)  not null default 'ACTIVE',

    valid_from     datetime     not null,
    valid_to       datetime     not null default '9999-12-31 23:59:59',
    is_current     boolean      not null default true,
    created_by     varchar(100) not null,

    index idx_product_id_valid_range (product_id, valid_from, valid_to),
    index idx_valid_range (valid_from, valid_to),
    index idx_is_current (is_current)
) 
```

data insert
```sql
INSERT INTO product (product_id, name, price, stock_quantity, status, valid_from, valid_to, is_current, created_by)
VALUES (1, '스마트폰 케이스', 15000, 100, 'ACTIVE', '2026-01-10 10:00:00', '9999-12-31 23:59:59', TRUE, 'admin_kim');

INSERT INTO product (product_id, name, price, stock_quantity, status, valid_from, valid_to, is_current, created_by)
VALUES (2, '무선 이어폰', 89000, 50, 'ACTIVE', '2026-01-10 10:05:00', '9999-12-31 23:59:59', TRUE, 'admin_lee');

SELECT history_id, product_id, name, price, valid_from, valid_to, is_current
FROM product;
```

data update
2 steps
1. an existing row's 
- valid_to is changed to the current time
- is_current is changed to false
2. insert a new row
```sql
-- 변경 시점 (현재로 가정)
SET @change_time = '2026-01-12 10:00:00';

-- 1. 기존 행의 유효 기간 종료
UPDATE product
SET valid_to = @change_time,
  is_current = FALSE
WHERE product_id = 1 AND is_current = TRUE;

-- 2. 새로운 행 추가
INSERT INTO product (product_id, name, price, stock_quantity, status, valid_from, valid_to, is_current, created_by)
VALUES (1, '스마트폰 케이스', 12000, 100, 'ACTIVE', @change_time, '9999-12-31 23:59:59', TRUE, 'admin_park');

SELECT history_id, product_id, name, price, valid_from, valid_to, is_current
FROM product
WHERE product_id = 1
ORDER BY valid_from;
```

data update one more
```sql
SET @change_time = '2026-01-14 14:00:00';

UPDATE product
SET valid_to = @change_time,
  is_current = FALSE
WHERE product_id = 1 AND is_current = TRUE;

INSERT INTO product (product_id, name, price, stock_quantity, status, valid_from, valid_to, is_current, created_by)
VALUES (1, '스마트폰 케이스', 10000, 95, 'ACTIVE', @change_time, '9999-12-31 23:59:59', TRUE, 'admin_kim');

SELECT history_id, product_id, name, price, stock_quantity, valid_from, valid_to, is_current
FROM product
WHERE product_id = 1
ORDER BY valid_from;
```

* specified time point - more simple query
2026-01-13, product_id=1 price
```sql
select *
from product
where product_id = 1
and valid_from <= '2026-01-13 23:59:59'
and '2026-01-13 23:59:59' < valid_to;
```

* current time query
```sql
select *
from product
where 
    valid_from <= now()
    and now() < valid_to;
```

* total statistics - performance improvement
in 2026-01-13, all product stock quantity
```sql
select sum(stock_quantity)
from product
where valid_from <= '2026-01-13 23:59:59'
and '2026-01-13 23:59:59' < valid_to;
```

* valid_to, is_current column duplication
pros using is_current
1. query readability
```sql
-- 1. valid_to(magic number required)
select *
from product
where valid_to = '9999-12-31 23:59:59';

-- 2. is_current
select *
from product
where is_current = TRUE;
```
2. performance benefit(index efficiency)
equality comparison would better than range search
- valid_to case: (product, valid_to)
- is_current case: (product, is_current)
index size using valid_to is bigger than using is_current

3. scalability to future
valid_to means current data in now, but in the future, it could be changed to another data.
for example, deleted data can be managed by is_deleted, or temporary saved status can be added
date is hard to know whether logically current active
is_current is clear to know the current active status

valid period 
pros 
1. query at a specific time is easy
2. statistics query is fast
3. all history is stored with a valid period
cons
1. valid_to must be required when data update
- a history table is mutable
2. transaction management is required
- update and insert must be atomic
3. data is appended continuously
- a single table has many rows

* valid period saved - SCD Type 2
when updated, insert a new row(version creation), but keep the existing row
- valid_from: start of a valid period
- valid_to: end of a valid period
