idea: if price is changed, price is saved only

```sql
use my_shop4;
DROP TABLE IF EXISTS product_change_log;

CREATE TABLE product_change_log (
    log_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    product_id BIGINT NOT NULL,
    column_name VARCHAR(100) NOT NULL,
    old_value VARCHAR(1000),
    new_value VARCHAR(1000),
    changed_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    changed_by VARCHAR(100) NOT NULL,
    change_reason VARCHAR(500),
    
    INDEX idx_product_id (product_id),
    INDEX idx_changed_at (changed_at),
    INDEX idx_column_name (column_name)
);
```
- column name: changed column name
- old value: old value of a changed column
- new value: new value of the changed column

```sql

-- 가격 변경: 15000 → 12000
INSERT INTO product_change_log (product_id, column_name, old_value, new_value, changed_by, changed_at, change_reason) VALUES (1, 'price', '15000', '12000', 'admin_park', '2026-03-01 10:00:00', '봄맞이 할인 이벤트');

-- 재고 변경: 100 → 95
INSERT INTO product_change_log (product_id, column_name, old_value, new_value, changed_by, changed_at, change_reason) VALUES (1, 'stock_quantity', '100', '95', 'warehouse_kim', '2026-03-15 14:00:00', '재고 실사 - 5개 파손');

-- 상태 변경: ACTIVE → INACTIVE
INSERT INTO product_change_log (product_id, column_name, old_value, new_value, changed_by, changed_at, change_reason) VALUES (1, 'status', 'ACTIVE', 'INACTIVE', 'admin_lee', '2026-04-01 10:00:00', '제조사 단종 통보');

select * from product_change_log;
```

pros
1. storage saving
2. diff is clear
cons
1. it is hard to know all columns status
at 2026-03-20, what is all columns value(product_id=1)
2. statistics query is very hard
2026-03-20, all product stock_quantity
- if change history does not exist, it is required to query original data
- very complex and slow
3. type information is lost
- all values are stored as string
4. initial data processing is complex

* variation using json
```sql
DROP TABLE IF EXISTS product_change_log_json;

CREATE TABLE product_change_log_json (
    log_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    product_id BIGINT NOT NULL,
    changes JSON NOT NULL,
    changed_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    changed_by VARCHAR(100) NOT NULL,
    
    INDEX idx_product_id (product_id)
);

-- 변경 내용을 JSON으로 저장
INSERT INTO product_change_log_json (product_id, changes, changed_by)
VALUES (1, '{"price": {"old": 15000, "new": 12000}, "stock_quantity": {"old": 100, "new": 95}}', 'admin_park');
```
- problem: still recovery at time, statistics query issue exists

| item                      | score |
|---------------------------|-------|
| size                      | good  |
| diff                      | good  |
| recovery at point         | hard  |
| statistics query          | hard  |
| implementation complexity | hard  |
| query complexity          | hard  |

* when to use?
1. only specific column change is required: price change history, status change history
2. total status recovery is not required
3. size is critical: large data volume, change is very frequent

* practice conclusion: use all columns snapshot first
1. development cost is more expensive than storage cost
- column log: implementation is complex, data query can make bug 
- all columns snapshot: select * is simple, impl is easy
2. past status recovery is core of history management
- snapshot is core
- query is more important than storage
3. ease to data analysis
- all column snapshots are easy to analyze
- column unit log is actually impossible to write a statistics query

* summary: history table design principle
1. default strategy: all columns snapshot
2. exceptional case: billion data volume, specific column(ex. board context) is huge
3. halfway strategy: if a description is very huge and others are not, store a snapshot without description or separate for description

simple is best. if there is a special reason, use a all column snapshot.