idea: one common history table for track all changes

table design
```sql
CREATE TABLE audit_log (
    audit_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    
    table_name VARCHAR(100) NOT NULL,
    record_id VARCHAR(100) NOT NULL,
    action VARCHAR(20) NOT NULL,
    
    old_data JSON,
    new_data JSON,
    
    changed_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    changed_by VARCHAR(100) NOT NULL,
    
    source_system VARCHAR(50),
    client_ip VARCHAR(50),
    request_id VARCHAR(100),
    
    INDEX idx_table_record (table_name, record_id),
    INDEX idx_changed_at (changed_at),
    INDEX idx_changed_by (changed_by)
);
```

insert data
```sql
-- 상품 등록
INSERT INTO audit_log (table_name, record_id, action, old_data, new_data, changed_by, changed_at, source_system)
VALUES (
    'product',
    '1',
    'INSERT',
    NULL,
    '{"product_id": 1, "name": "스마트폰 케이스", "price": 15000, "stock_quantity": 100}',
    'admin_kim',
    '2026-03-15 10:00:00',
    'WEB_ADMIN'
);

-- 주문 등록
INSERT INTO audit_log (table_name, record_id, action, old_data, new_data, changed_by, changed_at, source_system)
VALUES (
    'orders',
    '1001',
    'INSERT',
    NULL,
    '{"order_id": 1001, "member_id": 100, "total_amount": 15000, "status": "PENDING"}',
    'member_100',
    '2026-03-15 14:30:00',
    'WEB_USER'
);

-- 회원 정보 수정
INSERT INTO audit_log (table_name, record_id, action, old_data, new_data, changed_by, changed_at, source_system)
VALUES (
    'member',
    '100',
    'UPDATE',
    '{"member_id": 100, "name": "홍길동", "email": "hong@old.com"}',
    '{"member_id": 100, "name": "홍길동", "email": "hong@new.com"}',
    'member_100',
    '2026-03-15 15:00:00',
    'MOBILE_APP'
);
```

pros
1. centralized history table
2. simple implementation
3. all activities are tracked
cons
1. detail information must be parsed from json
2. recovery to point-in-time is hard
3. table size grows over time
4. index efficiency is low

* when to use?
1. all system audit
2. cause tracking when problem occurs: who, when, what to do
3. backup storage: first store, and use when needed
4. debugging: tracking changes in development/test environment

| data importance                  | history management method                     |
|----------------------------------|-----------------------------------------------|
| very important(price, order, ..) | dedicated history table(all columns snapshot) |
| important(member info, ..)       | dedicated history table, common history table |
| normal(setting, log, ..)         | common history table, log file                |
| low(temp data, ..)               | X                                             |

* practice warning: log and database
all logs should not be stored in database.
1. db is rich resource
- rdb is a very important and unscalable, bottleneck of system
- cpu, memory, disk i/o are all rich resources
- if "user enter to web page", "api request is called", "debugging log" are inserted in db,
  - problem: disk space is used up very fast
  - system failure occurs: db resource can be exhausted
2. storage selection by traffic
small traffic case(early stage startup, internal admin)
- for convenience, can store log in db
large traffic case(almost service)
- never store normal log in db
- store normal log(application, access) to a log file
- manage log files by log system like elk stack
3. business history vs system log
clear two types of log
- audit data: 
  - ex. who, when change order status, who update product price
  - data should be stored for customer service or legal requirement
- system log
  - debugging log, error stack trace, access history
  - it is just log, not data
  - store to log file

conclusion: db is not a trash can

Q&A: where a common history table(audit_log) is stored?
answer: store in db
1. it is business data
2. cs or amdin can query it immediately and easily
3. transaction consistency must be guaranteed
caution
- per a certain period, move to archive db and delete from production db
