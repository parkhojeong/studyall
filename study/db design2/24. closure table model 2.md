* all ancestor query
```sql
use my_shop4;
select *
from category_path
where descendant_id = 4;
```

* direct descendant query
```sql
select *
from category_path p
join category_closure c on p.descendant_id = c.category_id 
where ancestor_id = 1 and depth = 1;
```

* until specified depth
```sql
select *
from category_path p
         join category_closure c on p.descendant_id = c.category_id
where ancestor_id = 1 and depth <= 2;
```

* node addition
```sql
insert into category_closure(category_id, name) values(8, '게이밍노트북');

insert into category_path(ancestor_id, descendant_id, depth) values(8, 8, 0);

insert into category_path(ancestor_id, descendant_id, depth)                                                        
select ancestor_id, 8, depth+1 
from category_path
where descendant_id = 4;

select * from category_path where descendant_id = 8;
```

* node deletion
```sql
delete from category_path where descendant_id = 8;

delete from category_closure where category_id = 8;
```
- in practice, application logic handles this. node having child must not be deleted.

* adjacency list vs closure table

| item                          | adjacency list         | closure table          |
|-------------------------------|------------------------|------------------------|
| storage                       | efficient(n rows)      | un-efficient(O(n^2))   |
| direct descendant query       | fast                   | fast                   |
| all desendant/anscestor query | recursive cte required | very fast(simple join) |
| node addtion                  | very simple            | path addition required |
| node deletion                 | simple                 | path deletion required |
| change parent                 | very simple            | complex                |
| implementation complexity     | low                    | high                   |

* when to use closure table?
- when read is very frequent: a read ratio is very higher than a write ratio.
  - ex. the shopping mall category is read frequently. but not updated frequently.
- when data is huge.
  - ex. category is over 10,000 and the depth is deep
- when a recursive query is not supported: legacy system or under MySQL 5.7

- but almost cases, an adjacency list with cte is enough.
- if the hierarchy is not updated frequently. cache is recommended.  