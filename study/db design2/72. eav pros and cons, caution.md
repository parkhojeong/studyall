eav pros
- schema flexibility
- sparse data efficiency: used attribute is only used
- in the same category, product can have different attributes
- runtime attribute definition
eav cons
- query complexity
- data type constraint lost
- fk constraint lost
  - if an attribute value must reference a specific table, it cannot be forced
- index limitation
- join performance issue

practice tip: column separation by data type
1. data type guarantee
2. type comparison is possible
but only one column is used at a time
```sql
DROP TABLE IF EXISTS product_attribute_typed;

CREATE TABLE product_attribute_typed (
  attribute_id  BIGINT     NOT NULL AUTO_INCREMENT,
  product_id   BIGINT     NOT NULL,
  attr_name   VARCHAR(100)  NOT NULL,
  val_text    VARCHAR(255)  NULL, -- 문자열 값 저장
  val_int    INT      NULL, -- 숫자 값 저장
  val_date    DATETIME    NULL, -- 날짜 값 저장
  PRIMARY KEY (attribute_id)
);

-- 화면 패널 종류 (문자열)
INSERT INTO product_attribute_typed (product_id, attr_name, val_text)
VALUES (1, 'panel_type', 'OLED');

-- 배터리 용량 (숫자)
INSERT INTO product_attribute_typed (product_id, attr_name, val_int)
VALUES (1, 'battery_capacity', 5000);
```

* eav usage caution
- put core attribute in a main table
- ues eav only for extra attributes

* hybrid approach
- use `core attribute + eav` instead complete eav 