* wrong design
- incremental update can make error

requirement: 2026-01-01 sales stats aggregation
suppose: 2026-01-01 sales is 50,000

setup
```sql
-- 1. 테이블 초기화 및 0원 세팅
use my_shop5;
DROP TABLE IF EXISTS daily_sales_stats;

CREATE TABLE daily_sales_stats (
    stat_date DATE NOT NULL,
    total_order_count INT NOT NULL DEFAULT 0,
    total_sales_amount BIGINT NOT NULL DEFAULT 0,
    PRIMARY KEY (stat_date)
);

INSERT INTO daily_sales_stats (stat_date, total_order_count, total_sales_amount) 
VALUES ('2026-01-01', 0, 0);
```

* wrong batch scenario
trial 1
```sql
-- [배치 실행 1회차] 정상적인 상황
-- 1월 1일 매출 50,000원을 집계하여 더한다.
UPDATE daily_sales_stats
SET total_sales_amount = total_sales_amount + 50000,
  total_order_count = total_order_count + 1
WHERE stat_date = '2026-01-01';

-- 결과 확인
SELECT * FROM daily_sales_stats;
```

trial 2 after trial 1 failed
```sql
-- [배치 실행 2회차] 재실행 상황 (사고 발생)
-- 배치를 다시 실행하면 기존 값(50000)에 또 50,000원을 더해버린다.
UPDATE daily_sales_stats
SET total_sales_amount = total_sales_amount + 50000,
    total_order_count = total_order_count + 1
WHERE stat_date = '2026-01-01';

-- 결과 확인
SELECT * FROM daily_sales_stats;
```
- update is done twice. so, the total_sales_amount is 100,000. 
- it is non-idempotent.

- idempotency: same input, same output regardless of how many times it is executed.
- in this case, `total_sales_amount += 50000` is non-idempotent.
- batch job or stat query must be idempotent.

* correct design: idempotency
- simple approach: delete & insert strategy

practice: idempotent batch job implementation

setup
```sql
DROP TABLE IF EXISTS orders;

-- 주문 테이블 생성
CREATE TABLE orders (
  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,
  customer_id BIGINT NOT NULL,
  total_amount INT NOT NULL,
  order_status VARCHAR(20) NOT NULL,
  order_date DATETIME NOT NULL
);

INSERT INTO orders (customer_id, total_amount, order_status, order_date) VALUES
(1, 10000, 'COMPLETED', '2026-01-01 10:00:00'),
(2, 25000, 'COMPLETED', '2026-01-01 14:30:00'),
(3, 15000, 'COMPLETED', '2026-01-01 18:20:00')
```

step 1: delete row at the target date
```sql
delete from daily_sales_stats where stat_date = '2026-01-01';
```

step 2: insert row 
```sql
INSERT INTO daily_sales_stats (stat_date, total_order_count, total_sales_amount)
SELECT
  DATE(order_date),
  COUNT(*),
  SUM(total_amount)
FROM orders
WHERE order_date >= '2026-01-01 00:00:00'
 AND order_date < '2026-01-02 00:00:00'
 AND order_status = 'COMPLETED'
GROUP BY DATE(order_date);
```

check
```sql
select * from daily_sales_stats;
```

* handle past data changed(scenario: refund occurred)
requirement: 2026-01-01 sales refund
- how to handle stat data changed?
```sql
-- 1월 4일에 1월 1일자 주문을 취소함
UPDATE orders
SET order_status = 'CANCELLED'
WHERE order_id = 1;
```

simple approach: delete & insert
```sql
-- 1. 삭제
DELETE FROM daily_sales_stats WHERE stat_date = '2026-01-01';

-- 2. 재생성
INSERT INTO daily_sales_stats (stat_date, total_order_count, total_sales_amount)
SELECT
  DATE(order_date),
  COUNT(*),
  SUM(total_amount)
FROM orders
WHERE order_date >= '2026-01-01 00:00:00'
 AND order_date < '2026-01-02 00:00:00'
 AND order_status = 'COMPLETED'
GROUP BY DATE(order_date);
```

check
```sql
select * from daily_sales_stats;
```

conclusion
- batch must be idempotent. 
- simple is best(delete & insert)