- prepare table and data
```sql
use my_shop4;
DROP TABLE IF EXISTS payments;
DROP TABLE IF EXISTS orders;
DROP TABLE IF EXISTS members;
DROP TABLE IF EXISTS common_code_attribute; -- 복습시 문제가 되는 테이블 제거
DROP TABLE IF EXISTS common_code_detail;
DROP TABLE IF EXISTS common_code_group;

-- 그룹 코드 테이블
CREATE TABLE common_code_group (
  group_code VARCHAR(50) PRIMARY KEY,
  group_name VARCHAR(100) NOT NULL
);

-- 상세 코드 테이블
CREATE TABLE common_code_detail (
  group_code VARCHAR(50) NOT NULL,
  code VARCHAR(50) NOT NULL,
  name VARCHAR(100) NOT NULL,
  sort_order INT NOT NULL DEFAULT 0,
  use_yn CHAR(1) NOT NULL DEFAULT 'Y',
  PRIMARY KEY (group_code, code),
  FOREIGN KEY (group_code) REFERENCES common_code_group(group_code)
);

-- 회원 테이블
CREATE TABLE members (
  member_id BIGINT PRIMARY KEY AUTO_INCREMENT,
  name VARCHAR(50) NOT NULL,
  email VARCHAR(100) NOT NULL,
  grade VARCHAR(20) NOT NULL DEFAULT 'NORMAL'
);

-- 주문 테이블
CREATE TABLE orders (
  order_id BIGINT PRIMARY KEY AUTO_INCREMENT,
  member_id BIGINT NOT NULL,
  order_status VARCHAR(20) NOT NULL DEFAULT 'ORDER',
  total_amount INT NOT NULL,
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (member_id) REFERENCES members(member_id)
);

-- 결제 테이블
CREATE TABLE payments (
  payment_id BIGINT PRIMARY KEY AUTO_INCREMENT,
  order_id BIGINT NOT NULL,
  payment_method VARCHAR(20) NOT NULL,
  payment_status VARCHAR(20) NOT NULL DEFAULT 'PENDING',
  amount INT NOT NULL,
  FOREIGN KEY (order_id) REFERENCES orders(order_id)
);

-- 공통 코드 데이터
INSERT INTO common_code_group (group_code, group_name) VALUES
('ORDER_STATUS', '주문상태'),
('MEMBER_GRADE', '회원등급'),
('PAYMENT_STATUS', '결제상태'),
('PAYMENT_METHOD', '결제수단');

INSERT INTO common_code_detail (group_code, code, name, sort_order) VALUES
('ORDER_STATUS', 'ORDER', '주문접수', 1),
('ORDER_STATUS', 'PAID', '결제완료', 2),
('ORDER_STATUS', 'SHIPPING', '배송중', 3),
('ORDER_STATUS', 'DELIVERED', '배송완료', 4),
('ORDER_STATUS', 'CANCEL', '주문취소', 5),
('MEMBER_GRADE', 'NORMAL', '일반회원', 1),
('MEMBER_GRADE', 'VIP', 'VIP회원', 2),
('MEMBER_GRADE', 'VVIP', 'VVIP회원', 3),
('PAYMENT_STATUS', 'PENDING', '결제대기', 1),
('PAYMENT_STATUS', 'COMPLETE', '결제완료', 2),
('PAYMENT_STATUS', 'FAILED', '결제실패', 3),
('PAYMENT_STATUS', 'CANCEL', '결제취소', 4),
('PAYMENT_METHOD', 'CARD', '신용카드', 1),
('PAYMENT_METHOD', 'BANK', '계좌이체', 2),
('PAYMENT_METHOD', 'MOBILE', '휴대폰결제', 3);

-- 테스트 데이터
INSERT INTO members (name, email, grade) VALUES
('션', 'seon@example.com', 'NORMAL'),
('네이트', 'nate@example.com', 'VIP'),
('이순신', 'lee@example.com', 'VVIP');

INSERT INTO orders (member_id, order_status, total_amount, created_at) VALUES
(1, 'ORDER', 50000, '2026-01-15 10:00:00'),
(1, 'PAID', 75000, '2026-01-15 11:00:00'),
(2, 'SHIPPING', 120000, '2026-01-16 09:00:00'),
(2, 'DELIVERED', 85000, '2026-01-14 15:00:00'),
(3, 'CANCEL', 45000, '2026-01-13 14:00:00');

INSERT INTO payments (order_id, payment_method, payment_status, amount) VALUES
(1, 'CARD', 'PENDING', 50000),
(2, 'CARD', 'COMPLETE', 75000),
(3, 'BANK', 'COMPLETE', 120000),
(4, 'MOBILE', 'COMPLETE', 85000),
(5, 'CARD', 'CANCEL', 45000);
```

# problem1: query complexity increase
- query with member_grade display name, order_status display name
```sql
select
    o.order_id,
    m.name as member_name,
    o.order_status,
    os.name as order_status_name,
    o.total_amount
from orders o
join members m on o.member_id = m.member_id
join common_code_detail os
    on os.group_code = 'ORDER_STATUS' AND o.order_status = os.code
join common_code_detail mg
    on mg.group_code = 'MEMBER_GRADE' AND m.grade = mg.code
order by o.order_id;
```

# problem2: query 'code display name' is duplicated
- if in multiple usages, the query 'code display name' is duplicated by similar query
  - in an admin page
  - in service page
  - in api
- if a common_code_detail table schema is changed? -> all queries are affected
```sql
-- admin page
select
    o.order_id,
    m.name as member_name,
    o.order_status, 
    os.name as order_status_name, -- duplicated
    o.total_amount
from orders o
join members m on o.member_id = m.member_id
join common_code_detail os
    on os.group_code = 'ORDER_STATUS' and os.code = o.order_status
order by o.created_at desc;

-- service page
select
    o.order_id,
    o.order_status,
    os.name as order_status_name, -- duplicated
    o.total_amount
from orders o
join common_code_detail os
    on os.group_code = 'ORDER_STATUS' and os.code = o.order_status
order by o.created_at desc;

-- 배송중인 주문 목록 조회
SELECT
    o.order_id,
    m.name AS member_name,
    o.order_status,
    os.name AS order_status_name, -- duplicated
    o.total_amount
FROM orders o
JOIN members m ON o.member_id = m.member_id
JOIN common_code_detail os
    ON os.group_code = 'ORDER_STATUS' AND o.order_status = os.code
WHERE o.order_status = 'SHIPPING';
```

# problem3: how to cover variable case?
- case1: in orders, order_id, order_status are required
- case2: in orders, order_id, order_status, order_status_name are required

2 approaches
1. a SQL creation for case2 only, and case1 reuse
- pros: reusability
- cons: unnecessary field exists in case1 
2. SQL creation for both cases
- pros: proper field exists in both cases
- cons: similar query is made for both cases

# problem4: for code display name, the subquery method is also complex instead of join
```sql
select
    o.order_id,
    m.name as member_name,
    o.order_status,
    (select name from common_code_detail os
     where os.group_code = 'ORDER_STATUS' AND os.code = o.order_status) as order_status_name,
    m.grade,
    (select name from common_code_detail os
     where os.group_code = 'MEMBER_GRADE' AND os.code = m.grade) as member_grade_name
from orders o
join members m on o.member_id = m.member_id;
```

* practice problem - join hell
- if the query only `orders list`, to show display names requires 4~5 joins
- too many joins decrease readability and maintainability and performance