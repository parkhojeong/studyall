* hybrid strategy using common_code and application enum together
core idea of hybrid strategy
- enum: code definition, type safety, business logic
- common_code: display name, additional attributes, production flexibility

step 1: enum definition(only code)
```java
public enum OrderStatus {
    ORDER,
    PAID,
    SHIPPING,
    DELIVERED,
    CANCEL;
}
```

step 2: common_code table (display name, attributes)
```sql
-- 표시 이름과 속성은 공통 코드 테이블에서 관리
INSERT INTO common_code_detail (group_code, code, name, name_en, sort_order) VALUES
('ORDER_STATUS', 'ORDER', '주문접수', 'Order Received', 1),
('ORDER_STATUS', 'PAID', '결제완료', 'Payment Complete', 2),
('ORDER_STATUS', 'SHIPPING', '배송중', 'Shipping', 3),
('ORDER_STATUS', 'DELIVERED', '배송완료', 'Delivered', 4),
('ORDER_STATUS', 'CANCEL', '주문취소', 'Cancelled', 5);
```

step 3: use enum in business logic
```java
boolean canCancel(Order order){
    return order.status == OrderStatus.ORDER ||
            order.status == OrderStatus.PAID;
}
```

step 4: query display name in db or cache
```java
String getStatusDisplayName(OrderStatus status){ // suppose ENUM is PAID 
    return CommonCodeCache.getName("ORDER_STATUS", status.name());
}
```

| division             | enum                   | common_code               |
|----------------------|------------------------|---------------------------|
| code definition      | O                      | O                         |
| business logic       | O                      | X                         |
| type safety          | O                      | X                         |
| display name         | X                      | O                         |
| additional attribute | X                      | O                         |
| update in using      | X(deployment required) | O(immediately reflected)  |

* hybrid strategy maintenance rule
1. code is added by a developer
2. attribute is updated by admin
3. enum and common_code must be in sync
- test case is required to ensure sync

* hybrid strategy drawback and supplement method
problem: code is managed in two places
- supplement
  - sync is verified by test case
  - better strong verification: verification in application boot time
    - if application boot time fails, deployment is stopped


* summary
1. using code only for display name
- situation: just show a display name in UI or provide option in the dropdown
- example: bank code(kookmin/woori/shinhan), region code(seoul/busan/daegu)
- solution: use only common_code table
- reason: maintenance flexibility is top priority
2. using code only for business logic
- situation
  - in business logic, the control flow is based on code.
  - the display name is not important or is updated rarely
  - but strict branch control is required. when a typo is made, a critical bug occurs
- example: internal system control flag, fixed system constant, programming level type division
  - order status(ORDER/PAID/SHIPPING), member grade(VIP/NORMAL), payment method(credit/cash)
  - attribute is updated rarely, or not at all
- solution: use only application enum
- reason: code safety is a top priority
3. hybrid strategy is a good choice(logic + display name)
- situation: business logic is based on code, display name or attribute(like discount rate) is updated frequently
- example: order status(ORDER/PAID/SHIPPING), member grade(VIP/NORMAL), payment method(credit/cash)
- solution: use hybrid strategy(enum + common_code)
- reason: development safety is guaranteed by enum, maintenance flexibility is guaranteed by common_code

| division                  | 1. only common_code              | only enum                                  | hybrid strategy                                    |
|---------------------------|----------------------------------|--------------------------------------------|----------------------------------------------------|
| main usage                | simple display name, static data | internal logic control, type safety        | logic control + flexible maintence                 |
| type safety               | X(string is used)                | O(compile type verification)               | O(compile type verification)                       |
| maintenance flexibility   | O(reflected when db is updated)  | X(code update and deployment is required)  | O(display name/atrribute is reflected immediately) |
| implementation complexity | low                              | midium                                     | high(sync management required)                     |
| recommendation case       | bank code, country code          | order status, payment method, member grade | order status, payment method, member grade         |

* practice decision tree
[question1]: is code used for business logic(if statement)?
- no
  - using for display or select box -> use [1. common_code table]
- yes
  - if business logic is branched by code, specific status have to be validated -> jump to [question 2]
[question2]: display name or attribute is updated frequently?
- no
  - code is used for logic, but display name or attribute is updated rarely -> use [2. application enum]
  - example: gender(male/female), delivery policy(free/paid)
- yes
  - code is used for logic, display name or attribute is updated frequently -> use [3. hybrid strategy]
  - example: order status(display name is updated frequently), member grade(discount rate is updated frequently), coupon type

* practice selection tip
1. start simply: if code is used for logic, use enum first
2. extend when needed: when text is updated frequently, or attribute is managed by admin, refactor to hybrid strategy
3. sync is required: when hybrid strategy is used, validate sync by test case
