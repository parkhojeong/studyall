* in an adjacency list model
- a direct parent or child query is easy
- but all antecedent or descendant queries are hard

```sql
DROP TABLE IF EXISTS category;

CREATE TABLE category (
  category_id BIGINT   NOT NULL AUTO_INCREMENT,
  name     VARCHAR(100) NOT NULL,
  parent_id  BIGINT   NULL,
  PRIMARY KEY (category_id),
  FOREIGN KEY (parent_id) REFERENCES category(category_id)
);

-- 1단계: 최상위 카테고리 (루트)
INSERT INTO category (name, parent_id) VALUES ('전자제품', NULL);
INSERT INTO category (name, parent_id) VALUES ('의류', NULL);
INSERT INTO category (name, parent_id) VALUES ('식품', NULL);

-- 2단계: 전자제품의 하위 카테고리
INSERT INTO category (name, parent_id) VALUES ('컴퓨터', 1);
INSERT INTO category (name, parent_id) VALUES ('스마트폰', 1);
INSERT INTO category (name, parent_id) VALUES ('가전제품', 1);

-- 3단계: 컴퓨터의 하위 카테고리
INSERT INTO category (name, parent_id) VALUES ('노트북', 4);
INSERT INTO category (name, parent_id) VALUES ('데스크탑', 4);
INSERT INTO category (name, parent_id) VALUES ('태블릿', 4);

-- 3단계: 스마트폰의 하위 카테고리
INSERT INTO category (name, parent_id) VALUES ('애플', 5);
INSERT INTO category (name, parent_id) VALUES ('삼성', 5);

-- 3단계: 가전제품의 하위 카테고리
INSERT INTO category (name, parent_id) VALUES ('TV', 6);
INSERT INTO category (name, parent_id) VALUES ('냉장고', 6);

-- 2단계: 의류의 하위 카테고리
INSERT INTO category (name, parent_id) VALUES ('남성의류', 2);
INSERT INTO category (name, parent_id) VALUES ('여성의류', 2);

-- 3단계: 남성의류의 하위 카테고리
INSERT INTO category (name, parent_id) VALUES ('셔츠', 14);
INSERT INTO category (name, parent_id) VALUES ('바지', 14);
```

* approach1: repeat query in application layer
- step 1: query category_id=1
- step 2: query categories of parent_id=1
- step 3: query categories of parent_id in step2
- step n: if child is not exist anymore, stop 
```sql
select * from category where category_id = 1;

select * from category where parent_id = 1;

select * from category where parent_id in (4,5,6);

select * from category where parent_id in (7,8,9,10,11,12,13);
```
problem: too many queries

* approach2: fixed depth query using join
```sql
select 
    c1.category_id as level1_id,
    c1.name as level1_name,
    c2.category_id as level2_id,
    c2.name as level2_name,
    c3.category_id as level3_id,
    c3.name as level3_name
from category c1 
join category c2 on c1.category_id = c2.parent_id
join category c3 on c2.category_id = c3.parent_id
where c1.category_id = 1;
```
problem
- fixed depth query
- join is added for each level
- duplicated result

* approach3: query using union all
```sql
select category_id, name, parent_id, 1 as level
from category
where category_id = 1

union all

select category_id, name, parent_id, 2 as level
from category
where parent_id = 1

union all

select c.category_id, c.name, c.parent_id, 3 as level
from category c
where c.parent_id in (
    select category_id from category where parent_id = 1
) 
```
- fixed depth query

* difficulty to query ancestors
- how to query all ancestors of a category of id=7?
```sql
select * 
from category c1 
left join category c2 on c1.parent_id = c2.category_id
left join category c3 on c2.parent_id = c3.category_id
where c1.category_id = 7;
```

* requirement of specific depth query
- in electronics category, query until 2 levels

* summary
- these approaches have to know the depth

| aprroach                          | pros                            | cons                         |
|-----------------------------------|---------------------------------|------------------------------|
| repeat query in application layer | simple implementation           | network cost, repeat query   |
| join fixed depth                  | single query                    | fixed depth, low flexibility |
| union all                         | separation is possible by level | fixed depth, complex query   |

- conclusion: if depth is variable, it is hard to handle
- solution: recursive query in sql standard 
