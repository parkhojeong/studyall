* simple approach: select-insert-update
- select first. insert if not exists, else update

setup
```sql
use my_shop5;
DROP TABLE IF EXISTS intraday_sales_stats;

CREATE TABLE intraday_sales_stats (
  today_date DATE NOT NULL,
  total_order_count INT NOT NULL DEFAULT 0,
  total_sales_amount BIGINT NOT NULL DEFAULT 0,
  updated_at DATETIME,
  PRIMARY KEY (today_date)
);
```

step 1: select (check if it exists)
```sql
SELECT count(*)
FROM intraday_sales_stats
WHERE today_date = '2026-01-02';
```

step 2: insert if not exists, else update
case a: if not exists, insert
```sql
INSERT INTO intraday_sales_stats (today_date, total_order_count, total_sales_amount, updated_at)
SELECT
  DATE(order_date),
  COUNT(*),
  SUM(total_amount),
  '2026-01-02 00:05:00' -- NOW()를 사용해야 하지만, 예시에서는 직접 입력
FROM orders
WHERE order_date >= '2026-01-02' AND order_date < '2026-01-03'
 AND order_status = 'COMPLETED'
GROUP BY DATE(order_date);
```

case b: if exists, update
```sql
-- 애플리케이션에서 미리 계산된 값을 파라미터로 바인딩한다고 가정한다.
-- 여기서는 이해를 돕기 위해 서브쿼리를 사용해 값을 갱신한다.
UPDATE intraday_sales_stats
SET
  total_order_count = (SELECT COUNT(*) FROM orders WHERE order_date >= '2026-01-02' AND order_date < '2026-01-03' AND order_status = 'COMPLETED'),
  total_sales_amount = (SELECT SUM(total_amount) FROM orders WHERE order_date >= '2026-01-02' AND order_date < '2026-01-03' AND order_status = 'COMPLETED'),
  updated_at = '2026-01-02 00:10:00' -- NOW()를 사용해야 하지만, 예시에서는 직접 입력
WHERE today_date = '2026-01-02';
```

* select -> insert/update strategy summary
- it prevents delete operation, but it uses 2 round trips in a network
- improvement approach: if exists, update or insert with a condition

* advanced approach: upsert(update + insert)
MySQL support upsert. `on duplicate key update`
```sql 
INSERT INTO table_name (column1, column2, ...)
VALUES (value1, value2, ...)
ON DUPLICATE KEY UPDATE
 column1 = new_value,
 column2 = new_value;
```
- on duplicate key: if pk(or unique key) exists, update else insert

* upsert mechanism
1. try to insert
2. check duplicate key conflict
- if not, insert
- if yes, update 

setup
```sql
DROP TABLE IF EXISTS intraday_sales_stats;

CREATE TABLE intraday_sales_stats (
  today_date DATE NOT NULL,
  total_order_count INT NOT NULL DEFAULT 0,
  total_sales_amount BIGINT NOT NULL DEFAULT 0,
  updated_at DATETIME,
  PRIMARY KEY (today_date)
);
```

upsert (before MySQL 8.0.20+)
```sql
INSERT INTO intraday_sales_stats (today_date, total_order_count, total_sales_amount, updated_at)
SELECT
  DATE(order_date),
  COUNT(*),
  SUM(total_amount),
  NOW()
FROM orders
WHERE order_date >= '2026-01-02'
 AND order_status = 'COMPLETED'
GROUP BY DATE(order_date)
ON DUPLICATE KEY UPDATE
  total_order_count = VALUES(total_order_count), -- 입력하려고 했던 바로 그 값(New)
  total_sales_amount = VALUES(total_sales_amount), -- 입력하려고 했던 바로 그 값(New)
  updated_at = VALUES(updated_at);        -- 입력하려고 했던 바로 그 값(New)
```

upsert (since MySQL 8.0.20+) - VALUES() is deprecated
```sql
INSERT INTO intraday_sales_stats (today_date, total_order_count, total_sales_amount, updated_at)
SELECT * FROM (
  -- 1. 먼저 오늘치 데이터를 집계하는 서브쿼리를 만든다.
  SELECT
    DATE(order_date) as today_date,
    COUNT(*) as total_order_count,
    SUM(total_amount) as total_sales_amount,
    NOW() as updated_at
  FROM orders
  WHERE order_date >= '2026-01-02'
   AND order_status = 'COMPLETED'
  GROUP BY DATE(order_date)
) AS new_stats -- 2. 이 집계 결과(테이블)에 'new_stats'라는 별칭을 붙인다.
ON DUPLICATE KEY UPDATE
  total_order_count = new_stats.total_order_count, -- 서브쿼리의 값으로 덮어쓰기
  total_sales_amount = new_stats.total_sales_amount, -- 서브쿼리의 값으로 덮어쓰기
  updated_at = new_stats.updated_at;        -- 서브쿼리의 시간으로 갱신
```

check
```sql
SELECT * FROM intraday_sales_stats;
```
+----------+-----------------+------------------+-------------------+
|today_date|total_order_count|total_sales_amount|updated_at         |
+----------+-----------------+------------------+-------------------+
|2026-01-02|3                |200000            |2026-02-09 20:49:55|
+----------+-----------------+------------------+-------------------+

flow
1. select: aggregate from orders
2. try to insert: try to insert in intraday_sales_stats
3. if conflict occurs, `on duplicate key update` is executed
   - VALUES(total_sales_amount): select aggregation result
   - update is executed

* upsert pros
- atomicity: update or insert
- simplicity: simple single query
- idempotency: can be executed multiple times
- performance: no additional round trips, no deletion

* (delete & insert) vs upsert performance difference
1. index and log cost
- delete & insert
  1. all related index are updated for delete & insert
  2. log creation: delete log, update log
  3. page fragmentation: disk space is wasted
- upsert
  1. if the related index doesn't exist, the index is not updated
  2. minimal log creation: only insert/update log
  3. no page fragmentation
  4. network traffic optimization
2. actual performance difference
- if the index doesn't exist, it is similar
- normal table(index 3~5): 2~3 times 
- in many concurrency environments, it can be over 10 times

* summary: when, how to use
- daily/monthly stats batch(daybreak execution): recommend delete & insert
- real-time/micro-batch(frequent update): use upsert

* [advanced] incremental update
- if the order per day has billions of rows, aggregation needs 10 minutes
- approach: store last read id. after, read from there
1. batch_mata table store last_order_id
2. select ... from orders where order_id > last_order_id 
3. add existing stats value (update ... set count = count + new_count)
4. update last_order_id
caution: it is a non-idempotent operation
if not an extreme case, use upsert 