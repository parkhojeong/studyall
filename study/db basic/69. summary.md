* summary
- optimizer and choose index
  - optimizer chooses the better efficient method in using index or full scan
  - normally query over 20~25% of all data, choose full scan(sequential i/o)
    - by using index, original data is read for random i/o
  - in small data, a full scan could be better
- covering index
  - index including all columns to be queried
  - prevent random i/o
  - if EXPLAIN results `Extra: Using index`, it's covering index
- composite index general rule
1. use order as the index order
2. = condition first, range condition last
3. using order by, follow index order
- composite index1
  - using two or more columns to create index
  - columns order is very important.
  - if (A, B, C) index, then where A, B is good. but where C is bad.
  - if using index, filesort from `order by` clause can be omitted
- composite index2
  - if range condition is used from index, following column can't be indexed
    - because data from the range condition is applied to filter each row
- composite index3
  - = first, range last
  - use IN instead of range(>, >=). it can be indexed efficiently
- index design guideline
  - the most important criteria of index creation is cardinality
    - index to high cardinality is efficient
  - index creation guideline
    - column for where clause condition
    - column for join condition(fk)
    - column for order by
- index cons and cuation
  - index is not free
  - cost
    - use disk space for index
    - write operation need to update index. especially update operation seems like delete and insert.
    - classify write-heavy service and read-heavy service. 
      - create necessary index
      - delete unnecessary index