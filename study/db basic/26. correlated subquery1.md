* correlated subquery1
- requirement: by product, find product > avg(price) of its category

* why need correlated subquery?
- avg(price) is determined per each row
```
+------------+----------------------------+------------+---------+-------------------------------------------------------+
| product_id | name                       | category   | price   | Comparison Target (SQL Subquery)                      |
+------------+----------------------------+------------+---------+-------------------------------------------------------+
| 1          | 프리미엄 게이밍 마우스          | 전자기기      | 75000   | SELECT AVG(price) FROM products WHERE category='전자기기'|
+------------+----------------------------+------------+---------+-------------------------------------------------------+
| 2          | 기계식 키보드                 | 전자기기      | 120000  | SELECT AVG(price) FROM products WHERE category='전자기기'|
+------------+----------------------------+------------+---------+-------------------------------------------------------+
| 3          | 4K UHD 모니터                | 전자기기     | 350000  | SELECT AVG(price) FROM products WHERE category='전자기기'|
+------------+----------------------------+------------+---------+-------------------------------------------------------+
| 4          | 관계형 데이터베이스 입문         | 도서        | 28000   | SELECT AVG(price) FROM products WHERE category='도서'  |
+------------+----------------------------+------------+---------+-------------------------------------------------------+
| 5          | 고급 가죽 지갑                | 패션         | 150000  | SELECT AVG(price) FROM products WHERE category='패션'  |
+------------+----------------------------+------------+---------+-------------------------------------------------------+
| 6          | 스마트 워치                   | 전자기기     | 280000  | SELECT AVG(price) FROM products WHERE category='전자기기'|
+------------+----------------------------+------------+---------+-------------------------------------------------------+
```

- each row has different avg(price)
```sql
SELECT AVG(price) FROM products WHERE category = '전자기기'; -- product_id:1
SELECT AVG(price) FROM products WHERE category = '전자기기'; -- product_id:2
SELECT AVG(price) FROM products WHERE category = '전자기기'; -- product_id:3
SELECT AVG(price) FROM products WHERE category = '도서'; -- product_id:4
SELECT AVG(price) FROM products WHERE category = '패션'; -- product_id:5
SELECT AVG(price) FROM products WHERE category = '전자기기'; -- product_id:6
```

- sub query is evaluated per each row like this
```
SELECT AVG(price) FROM products WHERE category = {category};
```

* correlated subquery concept
- main query is related to sub query.
- sub query reference value of main query.

* Non-correlated vs Correlated 
- Non-correlated subquery: sub query execute only once. and use it in main query.
- Correlated subquery
  1. main query read one row
  2. pass value to sub query, and execute sub query
  3. main query where clause use result of sub query.
  4. repeat 1~3

* problem solution by correlated subquery
- 전자기기: ( 75000 + 120000 + 350000 + 280000 ) / 4 = 206,250
- 도서: 28,000 (one product)
- 패션: 150,000 (one product)
```sql
select *
from products p1
where p1.price >= (	
	select 
		avg(p2.price) 
	from products p2
	where p2.category = p1.category -- p1.category change per each row
);
```
```
1 - 프리미엄 게이밍 마우스 - 전자기기 - 75000 
2 - 기계식 키보드 - 전자기기 - 120000 
3 - 4K UHD 모니터 - 전자기기 - 350000 
4 - 관계형 데이터베이스 입문 - 도서 - 28000 
5 - 고급 가죽 지갑 - 패션 - 150000 
6 - 스마트 워치 - 전자기기 - 280000
```
* execution flow
- main query read products(p1)
- and execute each row of products(p1)
  1. main query read '프리미엄 게이밍 마우스', p1.category is '전자기기'
  2. sub query execution with '전자기기', select ... where p2.category = '전자기기'. result 206,250
  3. main query where clause changes to 75000 >= 206,250. false, so skip this row.
  4. repeat 1~3
- so, 206,250(전자기기), 28,000(도서), 150,000(패션) is used in where clause.
- results 전자기기(3 - 350,000,6 - 280,000), 도서(4), 패션(5)