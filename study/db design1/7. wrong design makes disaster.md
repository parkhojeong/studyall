* wrong design makes disaster

```
-- orders table
+----------+-------------+---------------+-----------------------+------------+--------------------+--------------+
| order_id | customer_id | customer_name | customer_address      | product_id | product_name       | product_price|
+----------+-------------+---------------+-----------------------+------------+--------------------+--------------+
| 1001     | user1       | 네이트          | 서울시 강남구            | P001       | 좋은 키보드           | 50000        |
| 1002     | user2       | 이철수          | 경기도 성남시            | P002       | 편한 마우스           | 30000        |
| 1003     | user1       | 네이트          | 서울시 강남구            | P002       | 편한 마우스           | 30000        |
| 1004     | user3       | 박영희          | 서울시 서초구            | P003       | 고성능 모니터          | 200000       |
| 1005     | user1       | 네이트          | 서울시 강남구            | P003       | 고성능 모니터          | 200000       |
+----------+-------------+---------------+-----------------------+------------+--------------------+--------------+
```
- wrong desing's big 3 problems
1. damage data integrity(reliability decreases)
* integrity(wikipedia): the maintenance of, and the assurance of, data accuracy and consistency over its entire life-cycle
- data duplication
- anomaly
  - update anomaly: for updating user1's address, all rows are updated 
  - insertion anomaly: for inserting user4, another columns except user-info must be null
  - deletion anomaly: if order_id=1002 is deleted, user2's info is deleted too
2. performance degradation(slow down)
  - table is too fat. amount to read data is too much.  
3. maintenance cost increased(scalability decreases)
  - if customer_grade is added and user2 grade set GOLD, all orders of user2 must be updated
    - only user info is updated, but order table is updated too.
  - application logic complexity increased: defensive logic must be added.