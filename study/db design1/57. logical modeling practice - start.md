* conceptual -> logical
1. entity -> table
2. attribute -> column
  - type, constraint
  ex. member_name VARCHAR(50) NOT NULL
3. identifier -> primary key
  - surrogate key
  ex. member_id BIGINT NOT NULL AUTO_INCREMENT
4. relationship -> foreign key & constraint
  - 1:n -> n side has fk
  - 1:1 -> child table has fk, unique
5. m:n -> junction table with pk(table1_id, table2_id)

* memo: what is the difference between logical and physical?
- logical type and physical type 
  - big number that automatically increments
    - BIGINT AUTO_INCREMENT(MySQL)
    - NUMBER(+ SEQUENCE)
    - BIGSERIAL(PostgreSQL)
  - variable length string
    - VARCHAR(n) (MySQL)
    - VARCHAR2(n) (Oracle)
    - VARCHAR(n) (PostgreSQL)
- logical modeling: blueprint of the data 
  - core: by rdbms theory, designing data logical structure(not depending on vendor)
  - example: member has member_name attribute, type is string
- physical modeling: how to store data in specific rdbms
  - core: implementation for specific rdbms(MySQL, Oracle, PostgreSQL)
  - example
    - consider String type to VARCHAR or TEXT
    - index strategy   

* theory vs practice: boundary is unclear
- in practice, designing logical and physical structure together is common
