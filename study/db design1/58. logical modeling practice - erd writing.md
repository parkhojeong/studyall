note: suppose AUTO_ID is unique number system generated by DB
# step1: key entity table design
member, product
1. member table
- pk: member_id(surrogate key)
- column definitions
  - member_id: BIGINT, PK, AUTO_ID
  - login_id: VARCHAR(50), unique
  - password: VARCHAR(255), hashed
  - member_name: VARCHAR(50)
  - email: VARCHAR(100), unique
  - address: VARCHAR(255), default delivery address
- notes
  - login_id, email are natural keys. apply unique to them
  - pk is surrogate key
2. product table
- pk: product_id(surrogate key)
- column definitions
  - product_id: BIGINT, PK, AUTO_ID
  - product_name: VARCHAR(100)
  - product_price: INT
  - stock_quantity: INT

# step2: table including relationship design(1:n, m:n)
orders, order_item
3. orders
- pk: order_id(surrogate key)
- fk: member_id
- column definitions
  - orders_id: BIGINT, PK, AUTO_ID
  - member_id: BIGINT, FK, NOT NULL
  - order_status: VARCHAR(20) (ex: ORDERED, SHIPPED, COMPLETED, CANCELLED)
  - order_date: DATETIME
- notes
  - orders table has a non-identifying relationship to member table
    - member_id is just fk
  - member must exist - not null constraint 
4. order_item
- pk: order_item_id(surrogate key)
- fk: order_id, product_id
- column definitions
  - order_item_id: BIGINT, PK, AUTO_ID
  - order_id: BIGINT, FK, NOT NULL, UNIQUE1
  - product_id: BIGINT, FK, NOT NULL, UNIQUE2
  - order_quantity: INT
  - unit_price: INT, price at time user order(snapshot)
- notes
  - order_item also has a non-identifying relationship
  - order_id and product_id are unique combination(UNIQUE1)
    - a product is unique in an order
  - unit_price is stored at the time of order. 
    - after, if product price may change, unit_price is not changed

# step3: 1:1 relationship design
delivery, payment. both are 1:1 relationship to orders
5. delivery
- pk: delivery_id(surrogate key)
- fk: orders_id
- column definitions
  - delivery_id: BIGINT, PK, AUTO_ID
  - orders_id: BIGINT, FK, NOT NULL, UNIQUE
  - delivery_status: VARCHAR(20) (ex: READY, SHIPPING, COMPLETED)
  - delivery_address: VARCHAR(255)
  - tracking_number: VARCHAR(50)
- notes
  - sub table has fk
  - fk is unique. so, 1:1 relationship is possible
6. payment
- pk: payment_id(surrogate key)
- fk: orders_id
- column definitions
  - payment_id: BIGINT, PK, AUTO_ID
  - orders_id: BIGINT, FK, NOT NULL, UNIQUE
  - payment_status: VARCHAR(20) (ex: PAID, FAILED)
  - payment_method: VARCHAR(50) (ex: CREDIT_CARD)
  - payment_price: INT
  - payment_date: DATETIME, payment time that bank, credit card system record

* practice story: model simplifying and tradeoff
- for speed, delivery and payment can be combined in an orders table
  - tradeoff: simplicity vs flexibility

* a korean and an English usage time
- conceptual model: recommend a korean
- logical model: recommend an English or Korean

* summary
- flexible and scalable, maintainable logical data model
- each table has a role and responsibility
- relationships is clear and easy to understand
- next, normalization is minimizing duplication and improving integrity for logical model quality 