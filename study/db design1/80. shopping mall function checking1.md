* member login 
```sql
explain
select
    member_id,
    login_id,
    password,
    member_name
from
    member
where
    login_id = 'sejong';
```

| id | table  | type  | key         | key_len | ref   | rows | filtered | Extra |
|----|--------|-------|-------------|---------|-------|------|----------|-------|
| 1  | member | const | uq_login_id | 202     | const | 1    | 100.00   |       |
- table: member table
- `type: const`: 'sejong' is used for constant, and single row is selected.
- `key: uq_login_id`: unique index is used.
- `rows:1`: optimizer estimates exactly that only one row is selected.
- conclusion: execution plan is optimized for login regardless of the number of rows.

practice tips
- login is used frequently
- security issue: password must be hashed(encrypt)

* user's order list 
```sql
explain 
select order_id, ordered_at, order_status, total_amount
from orders
where member_id = 6
order by ordered_at desc;
```

| id | table  | type | key              | key_len | ref   | rows | filtered | Extra          |
|----|--------|------|------------------|---------|-------|------|----------|----------------|
| 1  | orders | ref  | fk_orders_member | 8       | const | 2    | 100.00   | Using filesort |
- `table: orders`: orders table
- `type: ref`: equality comparison is used by index
- `key: fk_orders_member`: foreign key index is used for member_id
- `rows:2`: optimizer estimates exactly that two rows are selected.
- `Extra: Using filesort`
  - after selecting member_id, filesort is used to sort.
  - current it does not affect performance. but it will be improved in the future.

* user's order list query(denormalization effectiveness)
```sql
select
    o.order_id,
    o.ordered_at,
    o.order_status,
    o.total_amount
from orders o
where o.member_id = 6
order by o.ordered_at desc;
```
- by denormalization, a query is simple

* search product name
```sql
explain 
select product_id, product_name, product_price
from product
where product_name like 'JPA%';
```

| id | table   | type  | key              | key_len | rows | filtered | Extra                 |
|----|---------|-------|------------------|---------|------|----------|-----------------------|
| 1  | product | range | idx_product_name | 402     | 1    | 100.00   | Using index condition |
- `type: range`: search specific ranged data by index
- `key: idx_product_name`: use index exactly
- `rows:1`: optimizer estimates exactly that one row is selected.
- `Extra: Using index condition` reducing data access by index that filters data.

* admin query order(composite index)
```sql
explain 
select order_id, member_id, ordered_at, order_status
from orders
where order_status = 'CANCELLED'
AND ordered_at BETWEEN '2025-09-01 00:00:00' AND '2025-09-31 23:59:59';
```

| id | table  | type  | key                         | key_len | rows | filtered | Extra                 |
|----|--------|-------|-----------------------------|---------|------|----------|-----------------------|
| 1  | orders | range | idx_order_status_ordered_at | 87      | 1    | 100.00   | Using index condition |
- `type: range`: first order_status is equality condition. ordered_at is between condition, finally range type is used
- `key: idx_order_status_ordered_at`: use index exactly
- `rows:1`: by index filtering, optimizer estimates exactly that one row is selected.

* order detail query(denormalization effectiveness)
```sql
select order_item_id, product_name, order_price, order_quantity
from order_item
where order_id = 3;
```
- product_name is included in order_item table. so, join is not required.