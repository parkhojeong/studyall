* MySQL index auto creation
- pk, fk, uk(unique key)

scenario1
```sql
select member_id, password from member where member_id = 'user123';

select member_id from member where email = 'a@a.com';
```
- situations: in a member table, record counts are 1 million
- problem: a full table scan can occur
- solution: consider indexing to (member_id), (email)

scenario2
```sql
select *
from orders
where member_id = 10
order by ordered_at desc;
```
- situations: in a order table, record counts are 1 billion.
- problem: if member_id is not indexed, a full table scan occurs
- solution: index member_id
  
scenario3
```sql
select *
from product
where product_name like '노트북%'
```
- situations: in a product table, record counts are 10 million
- problem: if product_name is not indexed, a full table scan occurs
- solution: index product_name

scenario4
```sql
select *
from orders
where order_status = 'CANCELED'
AND ordered_at BETWEEN '2025-07-01 00:00:00' AND '2025-07-31 23:59:59';
```
- situations: in an orders table, record counts are 10 million
- problem: if order_status is indexed and ordered_at is indexed, optimizer can use one of them.
  - it can be still slow 
- solution: consider composite index (order_status, ordered_at)

* composite index column order
- put high selectivity and an equality condition first

scenario5
```sql
select *
from orders
where member_id = 10
AND order_status = 'COMPLETED'
AND ordered_at >= DATE_SUB(NOW(), INTERVAL 3 MONTH);
```
- situations: in an orders table, record counts are 10 billion
- if order_status = 'COMPLETED' cases are 1 billion, member_id = 10 cases are 1,000
  - member_id selectivity is very high
  - solution: index (member_id) is efficient 
  - workflow
    1. by index(member_id), scan only 1,000 rows fastly
    2. load in memory
    3. filter by order_status, ordered_at

* index cost
- is index(member_id, order_status, ordered_at) required?
- pros: query performance is improved
- cons
  - storage usage cost
  - write performance degradation: index is updated when records are updated
    - insert: when new record is inserted
    - update: when order_status is changed
    - delete: when order_status is changed

conclusion
- member_id could be a strong enough index if selectivity is very high
- index(member_id, order_status, ordered_at) could not be required

* index decision criteria
1. data distribution and query efficiency
- after filtering by member_id
  - ~1000: member_id index could be fast enough
  - 1000~: consider composite index
- in much traffic, consider composite index
2. write workload frequency and importance
an orders table has frequent insert and update workload
by composite index, write works can make performance issue
check tradeoff between read and write workload 
3. actual query pattern and performance monitoring
- slow query log analysis
- explain execution plan analysis: after filtering by member_id index, check rows to scan
- performance test